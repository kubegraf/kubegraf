{"version":3,"file":"resourceCache-DgXvRxiF.js","sources":["../../src/utils/resourceCache.ts"],"sourcesContent":["import { createSignal, createEffect, onCleanup } from 'solid-js';\nimport {\n  getCachedResource,\n  setCachedResource,\n  getCacheKey,\n  type ResourceCacheEntry,\n} from '../stores/globalStore';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in milliseconds (default: 15000)\n  backgroundRefresh?: boolean; // Whether to refresh in background (default: true)\n}\n\nexport interface CachedResourceResult<T> {\n  data: () => T | undefined;\n  loading: () => boolean;\n  error: () => Error | undefined;\n  refetch: () => Promise<void>;\n}\n\n// ============================================================================\n// Resource Cache Utility\n// ============================================================================\n\n/**\n * Creates a cached resource with background refresh capability.\n * \n * @param resourceType - The type of resource (e.g., 'pods', 'deployments')\n * @param fetchFn - Function that fetches the resource data\n * @param options - Cache options (TTL, background refresh)\n * @returns Reactive signals for data, loading, error, and refetch function\n */\nexport function createCachedResource<T>(\n  resourceType: keyof import('../stores/globalStore').ResourceCache,\n  fetchFn: () => Promise<T>,\n  options: CacheOptions = {}\n): CachedResourceResult<T> {\n  const { ttl = 15000, backgroundRefresh = true } = options;\n  \n  const [data, setData] = createSignal<T | undefined>(undefined);\n  const [loading, setLoading] = createSignal<boolean>(false);\n  const [error, setError] = createSignal<Error | undefined>(undefined);\n  const [isInitialLoad, setIsInitialLoad] = createSignal<boolean>(true);\n  const [lastCacheKey, setLastCacheKey] = createSignal<string>('');\n\n  // Check cache and load if available\n  const loadFromCache = (): boolean => {\n    const cached = getCachedResource<T>(resourceType);\n    if (cached) {\n      console.log(`[${resourceType}] Loading from cache, ${cached.data.length} items, age: ${Date.now() - cached.lastUpdated}ms`);\n      setData(cached.data);\n      setError(undefined);\n      return true;\n    }\n    console.log(`[${resourceType}] No cache found`);\n    return false;\n  };\n\n  // Fetch fresh data from API\n  const fetchFresh = async (isBackground = false): Promise<void> => {\n    if (!isBackground) {\n      setLoading(true);\n    }\n    setError(undefined);\n\n    try {\n      const freshData = await fetchFn();\n      \n      // Update cache\n      setCachedResource(resourceType, freshData);\n      \n      // Update data signal\n      setData(freshData);\n      \n      if (isInitialLoad()) {\n        setIsInitialLoad(false);\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      \n      // If we have cached data, keep it even on error\n      if (!data()) {\n        loadFromCache();\n      }\n    } finally {\n      if (!isBackground) {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Initial load: check cache first, then fetch in background if needed\n  const initialLoad = async (skipCache = false): Promise<void> => {\n    const currentKey = getCacheKey();\n    const cacheKeyChanged = currentKey !== lastCacheKey();\n    \n    // If cache key changed, skip cache and fetch fresh\n    if (skipCache || cacheKeyChanged) {\n      setLastCacheKey(currentKey);\n      await fetchFresh(false);\n      return;\n    }\n    \n    // Only load from cache if data is not already set\n    if (!data()) {\n      const hasCache = loadFromCache();\n      \n      if (hasCache && backgroundRefresh) {\n        // Return cached data immediately, refresh in background\n        setLastCacheKey(currentKey);\n        setIsInitialLoad(false);\n        fetchFresh(true).catch(err => {\n          console.warn(`Background refresh failed for ${resourceType}:`, err);\n        });\n      } else {\n        // No cache or background refresh disabled, fetch immediately\n        setLastCacheKey(currentKey);\n        await fetchFresh(false);\n      }\n    } else {\n      // Data already set, just update cache key\n      setLastCacheKey(currentKey);\n    }\n  };\n\n  // Refetch function (public API)\n  const refetch = async (): Promise<void> => {\n    await fetchFresh(false);\n  };\n\n  // Auto-refresh when cache key changes (cluster/namespaces change)\n  let refreshTimer: ReturnType<typeof setInterval> | null = null;\n  \n  createEffect(() => {\n    const currentKey = getCacheKey();\n    const cacheKeyChanged = currentKey !== lastCacheKey();\n    \n    // Clear existing timer\n    if (refreshTimer) {\n      clearInterval(refreshTimer);\n      refreshTimer = null;\n    }\n    \n    // If cache key changed (namespace/cluster changed), clear data immediately\n    // to prevent showing stale data from previous namespace/cluster\n    if (cacheKeyChanged && lastCacheKey() !== '') {\n      console.log(`[${resourceType}] Cache key changed from ${lastCacheKey()} to ${currentKey}, clearing data and fetching fresh`);\n      setData(undefined);\n      setError(undefined);\n    }\n    \n    // Initial load (will skip cache if key changed)\n    initialLoad(cacheKeyChanged);\n    \n    // Set up periodic refresh if background refresh is enabled\n    if (backgroundRefresh) {\n      refreshTimer = setInterval(() => {\n        const cached = getCachedResource<T>(resourceType);\n        if (cached) {\n          const age = Date.now() - cached.lastUpdated;\n          // Refresh if cache is older than TTL\n          if (age >= ttl) {\n            fetchFresh(true).catch(err => {\n              console.warn(`Background refresh failed for ${resourceType}:`, err);\n            });\n          }\n        }\n      }, Math.min(ttl, 5000)); // Check every 5 seconds or TTL, whichever is smaller\n    }\n  });\n\n  onCleanup(() => {\n    if (refreshTimer) {\n      clearInterval(refreshTimer);\n    }\n  });\n\n  return {\n    data,\n    loading,\n    error,\n    refetch,\n  };\n}\n\n/**\n * Creates a skeleton loader component data structure\n */\nexport function createSkeletonData<T>(count: number, template: () => T): T[] {\n  return Array.from({ length: count }, template);\n}\n\n\n"],"names":["error"],"mappings":";;AAoCO,SAAS,oBAAA,CACd,YAAA,EACA,OAAA,EACA,OAAA,GAAwB,EAAC,EACA;AACzB,EAAA,MAAM,EAAE,GAAA,GAAM,IAAA,EAAO,iBAAA,GAAoB,MAAK,GAAI,OAAA;AAElD,EAAA,MAAM,CAAC,IAAA,EAAM,OAAO,CAAA,GAAI,aAA4B,MAAS,CAAA;AAC7D,EAAA,MAAM,CAAC,OAAA,EAAS,UAAU,CAAA,GAAI,aAAsB,KAAK,CAAA;AACzD,EAAA,MAAM,CAAC,KAAA,EAAO,QAAQ,CAAA,GAAI,aAAgC,MAAS,CAAA;AACnE,EAAA,MAAM,CAAC,aAAA,EAAe,gBAAgB,CAAA,GAAI,aAAsB,IAAI,CAAA;AACpE,EAAA,MAAM,CAAC,YAAA,EAAc,eAAe,CAAA,GAAI,aAAqB,EAAE,CAAA;AAG/D,EAAA,MAAM,gBAAgB,MAAe;AACnC,IAAA,MAAM,MAAA,GAAS,kBAAqB,YAAY,CAAA;AAChD,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,EAAI,YAAY,CAAA,sBAAA,EAAyB,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,aAAA,EAAgB,IAAA,CAAK,GAAA,EAAI,GAAI,MAAA,CAAO,WAAW,CAAA,EAAA,CAAI,CAAA;AAC1H,MAAA,OAAA,CAAQ,OAAO,IAAI,CAAA;AACnB,MAAA,QAAA,CAAS,MAAS,CAAA;AAClB,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,EAAI,YAAY,CAAA,gBAAA,CAAkB,CAAA;AAC9C,IAAA,OAAO,KAAA;AAAA,EACT,CAAA;AAGA,EAAA,MAAM,UAAA,GAAa,OAAO,YAAA,GAAe,KAAA,KAAyB;AAChE,IAAA,IAAI,CAAC,YAAA,EAAc;AACjB,MAAA,UAAA,CAAW,IAAI,CAAA;AAAA,IACjB;AACA,IAAA,QAAA,CAAS,MAAS,CAAA;AAElB,IAAA,IAAI;AACF,MAAA,MAAM,SAAA,GAAY,MAAM,OAAA,EAAQ;AAGhC,MAAA,iBAAA,CAAkB,cAAc,SAAS,CAAA;AAGzC,MAAA,OAAA,CAAQ,SAAS,CAAA;AAEjB,MAAA,IAAI,eAAc,EAAG;AACnB,QAAA,gBAAA,CAAiB,KAAK,CAAA;AAAA,MACxB;AAAA,IACF,SAAS,GAAA,EAAK;AACZ,MAAA,MAAMA,MAAAA,GAAQ,eAAe,KAAA,GAAQ,GAAA,GAAM,IAAI,KAAA,CAAM,MAAA,CAAO,GAAG,CAAC,CAAA;AAChE,MAAA,QAAA,CAASA,MAAK,CAAA;AAGd,MAAA,IAAI,CAAC,MAAK,EAAG;AACX,QAAA,aAAA,EAAc;AAAA,MAChB;AAAA,IACF,CAAA,SAAE;AACA,MAAA,IAAI,CAAC,YAAA,EAAc;AACjB,QAAA,UAAA,CAAW,KAAK,CAAA;AAAA,MAClB;AAAA,IACF;AAAA,EACF,CAAA;AAGA,EAAA,MAAM,WAAA,GAAc,OAAO,SAAA,GAAY,KAAA,KAAyB;AAC9D,IAAA,MAAM,aAAa,WAAA,EAAY;AAC/B,IAAA,MAAM,eAAA,GAAkB,eAAe,YAAA,EAAa;AAGpD,IAAA,IAAI,aAAa,eAAA,EAAiB;AAChC,MAAA,eAAA,CAAgB,UAAU,CAAA;AAC1B,MAAA,MAAM,WAAW,KAAK,CAAA;AACtB,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,CAAC,MAAK,EAAG;AACX,MAAA,MAAM,WAAW,aAAA,EAAc;AAE/B,MAAA,IAAI,YAAY,iBAAA,EAAmB;AAEjC,QAAA,eAAA,CAAgB,UAAU,CAAA;AAC1B,QAAA,gBAAA,CAAiB,KAAK,CAAA;AACtB,QAAA,UAAA,CAAW,IAAI,CAAA,CAAE,KAAA,CAAM,CAAA,GAAA,KAAO;AAC5B,UAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,8BAAA,EAAiC,YAAY,CAAA,CAAA,CAAA,EAAK,GAAG,CAAA;AAAA,QACpE,CAAC,CAAA;AAAA,MACH,CAAA,MAAO;AAEL,QAAA,eAAA,CAAgB,UAAU,CAAA;AAC1B,QAAA,MAAM,WAAW,KAAK,CAAA;AAAA,MACxB;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,eAAA,CAAgB,UAAU,CAAA;AAAA,IAC5B;AAAA,EACF,CAAA;AAGA,EAAA,MAAM,UAAU,YAA2B;AACzC,IAAA,MAAM,WAAW,KAAK,CAAA;AAAA,EACxB,CAAA;AAGA,EAAA,IAAI,YAAA,GAAsD,IAAA;AAE1D,EAAA,YAAA,CAAa,MAAM;AACjB,IAAA,MAAM,aAAa,WAAA,EAAY;AAC/B,IAAA,MAAM,eAAA,GAAkB,eAAe,YAAA,EAAa;AAGpD,IAAA,IAAI,YAAA,EAAc;AAChB,MAAA,aAAA,CAAc,YAAY,CAAA;AAC1B,MAAA,YAAA,GAAe,IAAA;AAAA,IACjB;AAIA,IAAA,IAAI,eAAA,IAAmB,YAAA,EAAa,KAAM,EAAA,EAAI;AAC5C,MAAA,OAAA,CAAQ,GAAA,CAAI,IAAI,YAAY,CAAA,yBAAA,EAA4B,cAAc,CAAA,IAAA,EAAO,UAAU,CAAA,kCAAA,CAAoC,CAAA;AAC3H,MAAA,OAAA,CAAQ,MAAS,CAAA;AACjB,MAAA,QAAA,CAAS,MAAS,CAAA;AAAA,IACpB;AAGA,IAAA,WAAA,CAAY,eAAe,CAAA;AAG3B,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,YAAA,GAAe,YAAY,MAAM;AAC/B,QAAA,MAAM,MAAA,GAAS,kBAAqB,YAAY,CAAA;AAChD,QAAA,IAAI,MAAA,EAAQ;AACV,UAAA,MAAM,GAAA,GAAM,IAAA,CAAK,GAAA,EAAI,GAAI,MAAA,CAAO,WAAA;AAEhC,UAAA,IAAI,OAAO,GAAA,EAAK;AACd,YAAA,UAAA,CAAW,IAAI,CAAA,CAAE,KAAA,CAAM,CAAA,GAAA,KAAO;AAC5B,cAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,8BAAA,EAAiC,YAAY,CAAA,CAAA,CAAA,EAAK,GAAG,CAAA;AAAA,YACpE,CAAC,CAAA;AAAA,UACH;AAAA,QACF;AAAA,MACF,CAAA,EAAG,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,GAAI,CAAC,CAAA;AAAA,IACxB;AAAA,EACF,CAAC,CAAA;AAED,EAAA,SAAA,CAAU,MAAM;AACd,IAAA,IAAI,YAAA,EAAc;AAChB,MAAA,aAAA,CAAc,YAAY,CAAA;AAAA,IAC5B;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,OAAA;AAAA,IACA,KAAA;AAAA,IACA;AAAA,GACF;AACF;;;;"}