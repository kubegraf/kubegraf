// Copyright 2025 KubeGraf Contributors
// SPDX-License-Identifier: Apache-2.0

package main

/*
// TEMPORARILY DISABLED - RCA Engine integration pending
// To enable: add rcaEngine *RCAEngine to WebServer struct

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
)
*/

// handleRCAAnalyze handles RCA analysis requests
func (ws *WebServer) handleRCAAnalyze(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req AnalysisRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
		return
	}

	// Validate request
	if err := ws.rcaEngine.ValidateAnalysisRequest(req); err != nil {
		http.Error(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
		return
	}

	// Perform analysis
	response, err := ws.rcaEngine.AnalyzeIncident(r.Context(), req)
	if err != nil {
		http.Error(w, fmt.Sprintf("Analysis failed: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// handleRCAAnalyzeIncident analyzes a specific incident by ID
func (ws *WebServer) handleRCAAnalyzeIncident(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	incidentID := r.URL.Query().Get("id")
	if incidentID == "" {
		http.Error(w, "Incident ID is required", http.StatusBadRequest)
		return
	}

	namespace := r.URL.Query().Get("namespace")

	// Get the incident from incident scanner
	scanner := NewIncidentScanner(ws.app)
	incidents := scanner.ScanAllIncidents(namespace)

	// Find the specific incident
	var targetIncident *KubernetesIncident
	for _, incident := range incidents {
		if incident.ID == incidentID {
			targetIncident = &incident
			break
		}
	}

	if targetIncident == nil {
		http.Error(w, "Incident not found", http.StatusNotFound)
		return
	}

	// Perform RCA
	response, err := ws.rcaEngine.AnalyzeKubernetesIncident(r.Context(), *targetIncident)
	if err != nil {
		http.Error(w, fmt.Sprintf("Analysis failed: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// handleRCAQuickAnalyze performs a quick analysis of a resource
func (ws *WebServer) handleRCAQuickAnalyze(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	kind := r.URL.Query().Get("kind")
	name := r.URL.Query().Get("name")
	namespace := r.URL.Query().Get("namespace")

	if kind == "" || name == "" {
		http.Error(w, "Kind and name are required", http.StatusBadRequest)
		return
	}

	resource := ResourceReference{
		Kind:      kind,
		Name:      name,
		Namespace: namespace,
	}

	response, err := ws.rcaEngine.QuickAnalyze(r.Context(), resource, namespace)
	if err != nil {
		http.Error(w, fmt.Sprintf("Analysis failed: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// handleRCABatchAnalyze analyzes multiple incidents at once
func (ws *WebServer) handleRCABatchAnalyze(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var incidents []KubernetesIncident
	if err := json.NewDecoder(r.Body).Decode(&incidents); err != nil {
		http.Error(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
		return
	}

	if len(incidents) == 0 {
		http.Error(w, "No incidents provided", http.StatusBadRequest)
		return
	}

	if len(incidents) > 50 {
		http.Error(w, "Maximum 50 incidents per batch", http.StatusBadRequest)
		return
	}

	results, err := ws.rcaEngine.BatchAnalyze(r.Context(), incidents)
	if err != nil {
		http.Error(w, fmt.Sprintf("Batch analysis failed: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"results": results,
		"total":   len(results),
	})
}

// handleRCAPatterns returns information about supported correlation patterns
func (ws *WebServer) handleRCAPatterns(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	patterns := ws.rcaEngine.GetSupportedPatterns()

	patternInfo := make([]map[string]interface{}, len(patterns))
	for i, pattern := range patterns {
		patternInfo[i] = map[string]interface{}{
			"pattern":     pattern,
			"explanation": ws.rcaEngine.ExplainPattern(pattern),
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"patterns": patternInfo,
		"total":    len(patterns),
	})
}

// handleRCAFixSuggestions returns fix suggestions for a specific RCA
func (ws *WebServer) handleRCAFixSuggestions(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var rca RootCauseAnalysis
	if err := json.NewDecoder(r.Body).Decode(&rca); err != nil {
		http.Error(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
		return
	}

	fixes := ws.rcaEngine.fixRecommender.RecommendFixes(&rca)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"fixes": fixes,
		"total": len(fixes),
	})
}

// handleRCAIncidentsWithAnalysis returns incidents with their RCA analysis
func (ws *WebServer) handleRCAIncidentsWithAnalysis(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	namespace := r.URL.Query().Get("namespace")
	limitStr := r.URL.Query().Get("limit")

	limit := 10 // Default limit
	if limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 50 {
			limit = l
		}
	}

	// Get incidents
	scanner := NewIncidentScanner(ws.app)
	incidents := scanner.ScanAllIncidents(namespace)

	// Limit incidents
	if len(incidents) > limit {
		incidents = incidents[:limit]
	}

	// Analyze each incident (limit to prevent overload)
	results := make([]map[string]interface{}, len(incidents))
	for i, incident := range incidents {
		// Perform quick RCA
		response, err := ws.rcaEngine.AnalyzeKubernetesIncident(r.Context(), incident)

		results[i] = map[string]interface{}{
			"incident": incident,
			"rca":      nil,
			"error":    nil,
		}

		if err == nil && response != nil && response.Success {
			results[i]["rca"] = response.RCA
		} else if err != nil {
			results[i]["error"] = err.Error()
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"incidents": results,
		"total":     len(results),
	})
}

/*
// registerRCAHandlers registers all RCA-related HTTP handlers
func (ws *WebServer) registerRCAHandlers() {
	// Initialize RCA engine if not already initialized
	if ws.rcaEngine == nil {
		ws.rcaEngine = NewRCAEngine(ws.app)
	}

	// Register handlers
	http.HandleFunc("/api/rca/analyze", ws.handleRCAAnalyze)
	http.HandleFunc("/api/rca/analyze-incident", ws.handleRCAAnalyzeIncident)
	http.HandleFunc("/api/rca/quick-analyze", ws.handleRCAQuickAnalyze)
	http.HandleFunc("/api/rca/batch-analyze", ws.handleRCABatchAnalyze)
	http.HandleFunc("/api/rca/patterns", ws.handleRCAPatterns)
	http.HandleFunc("/api/rca/fix-suggestions", ws.handleRCAFixSuggestions)
	http.HandleFunc("/api/rca/incidents-with-analysis", ws.handleRCAIncidentsWithAnalysis)
}
*/
