// Copyright 2025 KubeGraf Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
)

type HelmRelease struct {
	Name       string `json:"name"`
	Namespace  string `json:"namespace"`
	Revision   int    `json:"revision"`
	Status     string `json:"status"`
	Chart      string `json:"chart"`
	AppVersion string `json:"appVersion"`
	Updated    string `json:"updated"`
}

// handleHelmReleases returns all Helm releases in the cluster
func (ws *WebServer) handleHelmReleases(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.clientset == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	namespace := r.URL.Query().Get("namespace")

	var releases []HelmRelease

	// Helm stores releases as secrets with owner=helm label
	listOptions := metav1.ListOptions{
		LabelSelector: "owner=helm",
	}

	var secrets *v1.SecretList
	var err error

	if namespace == "" || namespace == "All Namespaces" {
		secrets, err = ws.app.clientset.CoreV1().Secrets("").List(ws.app.ctx, listOptions)
	} else {
		secrets, err = ws.app.clientset.CoreV1().Secrets(namespace).List(ws.app.ctx, listOptions)
	}

	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	// Parse Helm secrets to extract release information
	releaseMap := make(map[string]*HelmRelease)

	for _, secret := range secrets.Items {
		// Get release name from label
		releaseName := secret.Labels["name"]
		if releaseName == "" {
			continue
		}

		// Get status from label
		status := secret.Labels["status"]
		if status == "" {
			status = "unknown"
		}

		// Get version/revision
		versionStr := secret.Labels["version"]
		version := 1
		if versionStr != "" {
			if v, err := strconv.Atoi(versionStr); err == nil {
				version = v
			}
		}

		key := fmt.Sprintf("%s/%s", secret.Namespace, releaseName)

		// Keep only the latest revision
		if existing, ok := releaseMap[key]; ok {
			if version > existing.Revision {
				releaseMap[key] = &HelmRelease{
					Name:      releaseName,
					Namespace: secret.Namespace,
					Revision:  version,
					Status:    status,
					Chart:     extractChartName(secret.Data),
					Updated:   secret.CreationTimestamp.Format("2006-01-02 15:04:05"),
				}
			}
		} else {
			releaseMap[key] = &HelmRelease{
				Name:      releaseName,
				Namespace: secret.Namespace,
				Revision:  version,
				Status:    status,
				Chart:     extractChartName(secret.Data),
				Updated:   secret.CreationTimestamp.Format("2006-01-02 15:04:05"),
			}
		}
	}

	// Convert map to slice
	for _, release := range releaseMap {
		releases = append(releases, *release)
	}

	// Sort by namespace then name
	sort.Slice(releases, func(i, j int) bool {
		if releases[i].Namespace != releases[j].Namespace {
			return releases[i].Namespace < releases[j].Namespace
		}
		return releases[i].Name < releases[j].Name
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":  true,
		"releases": releases,
		"count":    len(releases),
	})
}

// extractChartName tries to extract chart name from Helm secret data
func extractChartName(data map[string][]byte) string {
	// Helm 3 stores release data in a "release" key, gzip compressed and base64 encoded
	// For simplicity, we'll just return a placeholder
	// Full implementation would decode and decompress the data
	return "chart"
}

// handleHelmReleaseDetails returns details for a specific Helm release
func (ws *WebServer) handleHelmReleaseDetails(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.clientset == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	name := r.URL.Query().Get("name")
	namespace := r.URL.Query().Get("namespace")

	if name == "" || namespace == "" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name and namespace are required",
		})
		return
	}

	// Get all secrets for this release
	listOptions := metav1.ListOptions{
		LabelSelector: fmt.Sprintf("owner=helm,name=%s", name),
	}

	secrets, err := ws.app.clientset.CoreV1().Secrets(namespace).List(ws.app.ctx, listOptions)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	var history []map[string]interface{}
	for _, secret := range secrets.Items {
		versionStr := secret.Labels["version"]
		version := 1
		if versionStr != "" {
			if v, err := strconv.Atoi(versionStr); err == nil {
				version = v
			}
		}

		history = append(history, map[string]interface{}{
			"revision":  version,
			"status":    secret.Labels["status"],
			"updated":   secret.CreationTimestamp.Format("2006-01-02 15:04:05"),
			"createdAt": secret.CreationTimestamp,
		})
	}

	// Sort by revision descending
	sort.Slice(history, func(i, j int) bool {
		return history[i]["revision"].(int) > history[j]["revision"].(int)
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"name":      name,
		"namespace": namespace,
		"history":   history,
	})
}

// handleHelmReleaseHistory returns the full history for a Helm release
func (ws *WebServer) handleHelmReleaseHistory(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.clientset == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	name := r.URL.Query().Get("name")
	namespace := r.URL.Query().Get("namespace")

	if name == "" || namespace == "" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name and namespace are required",
		})
		return
	}

	// Get all secrets for this release
	listOptions := metav1.ListOptions{
		LabelSelector: fmt.Sprintf("owner=helm,name=%s", name),
	}

	secrets, err := ws.app.clientset.CoreV1().Secrets(namespace).List(ws.app.ctx, listOptions)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	var history []map[string]interface{}
	for _, secret := range secrets.Items {
		versionStr := secret.Labels["version"]
		version := 1
		if versionStr != "" {
			if v, err := strconv.Atoi(versionStr); err == nil {
				version = v
			}
		}

		// Get chart info from secret data
		chart := "unknown"
		appVersion := ""
		description := ""

		// Try to decode the release data
		if releaseData, ok := secret.Data["release"]; ok {
			// Helm stores release data as base64 + gzip + protobuf
			// For simplicity, we'll just get what we can from labels
			_ = releaseData
		}

		history = append(history, map[string]interface{}{
			"revision":    version,
			"status":      secret.Labels["status"],
			"chart":       chart,
			"appVersion":  appVersion,
			"description": description,
			"updated":     secret.CreationTimestamp.Format("2006-01-02 15:04:05"),
			"createdAt":   secret.CreationTimestamp,
		})
	}

	// Sort by revision descending
	sort.Slice(history, func(i, j int) bool {
		return history[i]["revision"].(int) > history[j]["revision"].(int)
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"name":      name,
		"namespace": namespace,
		"history":   history,
		"total":     len(history),
	})
}

// handleHelmRollback rolls back a Helm release to a specific revision
func (ws *WebServer) handleHelmRollback(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if r.Method != "POST" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Method not allowed",
		})
		return
	}

	if ws.app.clientset == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	// Parse request body
	var req struct {
		Name      string `json:"name"`
		Namespace string `json:"namespace"`
		Revision  int    `json:"revision"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Invalid request body: " + err.Error(),
		})
		return
	}

	if req.Name == "" || req.Namespace == "" || req.Revision == 0 {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name, namespace, and revision are required",
		})
		return
	}

	// Execute helm rollback command
	cmd := exec.Command("helm", "rollback", req.Name, strconv.Itoa(req.Revision), "-n", req.Namespace)
	output, err := cmd.CombinedOutput()

	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   fmt.Sprintf("Rollback failed: %s - %s", err.Error(), string(output)),
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":  true,
		"message":  fmt.Sprintf("Successfully rolled back %s to revision %d", req.Name, req.Revision),
		"output":   string(output),
		"name":     req.Name,
		"revision": req.Revision,
	})
}

// KustomizeResource represents a resource managed by Kustomize
type KustomizeResource struct {
	Kind      string            `json:"kind"`
	Name      string            `json:"name"`
	Namespace string            `json:"namespace"`
	Age       string            `json:"age"`
	Labels    map[string]string `json:"labels"`
}

// handleKustomizeResources returns resources managed by Kustomize
func (ws *WebServer) handleKustomizeResources(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.clientset == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	namespace := r.URL.Query().Get("namespace")

	var resources []KustomizeResource

	// Query deployments with kustomize managed-by label
	deploymentListOptions := metav1.ListOptions{
		LabelSelector: "app.kubernetes.io/managed-by=kustomize",
	}

	var deployments interface{}
	var err error

	if namespace == "" || namespace == "All Namespaces" {
		deployments, err = ws.app.clientset.AppsV1().Deployments("").List(ws.app.ctx, deploymentListOptions)
	} else {
		deployments, err = ws.app.clientset.AppsV1().Deployments(namespace).List(ws.app.ctx, deploymentListOptions)
	}

	if err == nil {
		if depList, ok := deployments.(*appsv1.DeploymentList); ok {
			for _, dep := range depList.Items {
				resources = append(resources, KustomizeResource{
					Kind:      "Deployment",
					Name:      dep.Name,
					Namespace: dep.Namespace,
					Age:       formatAge(time.Since(dep.CreationTimestamp.Time)),
					Labels:    dep.Labels,
				})
			}
		}
	}

	// Query services with kustomize managed-by label
	if namespace == "" || namespace == "All Namespaces" {
		svcList, err := ws.app.clientset.CoreV1().Services("").List(ws.app.ctx, deploymentListOptions)
		if err == nil {
			for _, svc := range svcList.Items {
				resources = append(resources, KustomizeResource{
					Kind:      "Service",
					Name:      svc.Name,
					Namespace: svc.Namespace,
					Age:       formatAge(time.Since(svc.CreationTimestamp.Time)),
					Labels:    svc.Labels,
				})
			}
		}
	} else {
		svcList, err := ws.app.clientset.CoreV1().Services(namespace).List(ws.app.ctx, deploymentListOptions)
		if err == nil {
			for _, svc := range svcList.Items {
				resources = append(resources, KustomizeResource{
					Kind:      "Service",
					Name:      svc.Name,
					Namespace: svc.Namespace,
					Age:       formatAge(time.Since(svc.CreationTimestamp.Time)),
					Labels:    svc.Labels,
				})
			}
		}
	}

	// Query ConfigMaps with kustomize managed-by label
	if namespace == "" || namespace == "All Namespaces" {
		cmList, err := ws.app.clientset.CoreV1().ConfigMaps("").List(ws.app.ctx, deploymentListOptions)
		if err == nil {
			for _, cm := range cmList.Items {
				resources = append(resources, KustomizeResource{
					Kind:      "ConfigMap",
					Name:      cm.Name,
					Namespace: cm.Namespace,
					Age:       formatAge(time.Since(cm.CreationTimestamp.Time)),
					Labels:    cm.Labels,
				})
			}
		}
	} else {
		cmList, err := ws.app.clientset.CoreV1().ConfigMaps(namespace).List(ws.app.ctx, deploymentListOptions)
		if err == nil {
			for _, cm := range cmList.Items {
				resources = append(resources, KustomizeResource{
					Kind:      "ConfigMap",
					Name:      cm.Name,
					Namespace: cm.Namespace,
					Age:       formatAge(time.Since(cm.CreationTimestamp.Time)),
					Labels:    cm.Labels,
				})
			}
		}
	}

	// Sort by namespace then kind then name
	sort.Slice(resources, func(i, j int) bool {
		if resources[i].Namespace != resources[j].Namespace {
			return resources[i].Namespace < resources[j].Namespace
		}
		if resources[i].Kind != resources[j].Kind {
			return resources[i].Kind < resources[j].Kind
		}
		return resources[i].Name < resources[j].Name
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"resources": resources,
		"count":     len(resources),
	})
}

// ArgoCDApp represents an ArgoCD Application
type ArgoCDApp struct {
	Name       string `json:"name"`
	Namespace  string `json:"namespace"`
	Project    string `json:"project"`
	SyncStatus string `json:"syncStatus"`
	Health     string `json:"health"`
	RepoURL    string `json:"repoURL"`
	Path       string `json:"path"`
	Revision   string `json:"revision"`
	Cluster    string `json:"cluster"`
	Age        string `json:"age"`
}

// handleArgoCDApps returns ArgoCD Applications
func (ws *WebServer) handleArgoCDApps(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.config == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     "Not connected to cluster",
			"installed": false,
		})
		return
	}

	namespace := r.URL.Query().Get("namespace")

	// Create dynamic client for CRD access
	dynamicClient, err := dynamic.NewForConfig(ws.app.config)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     err.Error(),
			"installed": false,
		})
		return
	}

	// ArgoCD Application GVR
	appGVR := schema.GroupVersionResource{
		Group:    "argoproj.io",
		Version:  "v1alpha1",
		Resource: "applications",
	}

	var apps []ArgoCDApp
	var appList *unstructured.UnstructuredList

	if namespace == "" || namespace == "All Namespaces" {
		appList, err = dynamicClient.Resource(appGVR).Namespace("").List(ws.app.ctx, metav1.ListOptions{})
	} else {
		appList, err = dynamicClient.Resource(appGVR).Namespace(namespace).List(ws.app.ctx, metav1.ListOptions{})
	}

	if err != nil {
		// Check if ArgoCD is not installed
		if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "no matches") {
			json.NewEncoder(w).Encode(map[string]interface{}{
				"success":   true,
				"apps":      []ArgoCDApp{},
				"count":     0,
				"installed": false,
				"message":   "ArgoCD is not installed in this cluster",
			})
			return
		}
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     err.Error(),
			"installed": false,
		})
		return
	}

	for _, item := range appList.Items {
		spec, _, _ := unstructured.NestedMap(item.Object, "spec")
		status, _, _ := unstructured.NestedMap(item.Object, "status")

		syncStatus := "Unknown"
		health := "Unknown"

		if syncStatusMap, ok := status["sync"].(map[string]interface{}); ok {
			if s, ok := syncStatusMap["status"].(string); ok {
				syncStatus = s
			}
		}

		if healthMap, ok := status["health"].(map[string]interface{}); ok {
			if h, ok := healthMap["status"].(string); ok {
				health = h
			}
		}

		project := "default"
		if p, ok := spec["project"].(string); ok {
			project = p
		}

		repoURL := ""
		path := ""
		revision := ""
		if source, ok := spec["source"].(map[string]interface{}); ok {
			if r, ok := source["repoURL"].(string); ok {
				repoURL = r
			}
			if p, ok := source["path"].(string); ok {
				path = p
			}
			if rev, ok := source["targetRevision"].(string); ok {
				revision = rev
			}
		}

		cluster := ""
		if dest, ok := spec["destination"].(map[string]interface{}); ok {
			if s, ok := dest["server"].(string); ok {
				cluster = s
			} else if n, ok := dest["name"].(string); ok {
				cluster = n
			}
		}

		creationTime := item.GetCreationTimestamp()

		apps = append(apps, ArgoCDApp{
			Name:       item.GetName(),
			Namespace:  item.GetNamespace(),
			Project:    project,
			SyncStatus: syncStatus,
			Health:     health,
			RepoURL:    repoURL,
			Path:       path,
			Revision:   revision,
			Cluster:    cluster,
			Age:        formatAge(time.Since(creationTime.Time)),
		})
	}

	// Sort by namespace then name
	sort.Slice(apps, func(i, j int) bool {
		if apps[i].Namespace != apps[j].Namespace {
			return apps[i].Namespace < apps[j].Namespace
		}
		return apps[i].Name < apps[j].Name
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"apps":      apps,
		"count":     len(apps),
		"installed": true,
	})
}

// handleArgoCDAppDetails returns details for a specific ArgoCD Application
func (ws *WebServer) handleArgoCDAppDetails(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.config == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	name := r.URL.Query().Get("name")
	namespace := r.URL.Query().Get("namespace")

	if name == "" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name is required",
		})
		return
	}

	// Default to argocd namespace if not specified
	if namespace == "" {
		namespace = "argocd"
	}

	dynamicClient, err := dynamic.NewForConfig(ws.app.config)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	appGVR := schema.GroupVersionResource{
		Group:    "argoproj.io",
		Version:  "v1alpha1",
		Resource: "applications",
	}

	app, err := dynamicClient.Resource(appGVR).Namespace(namespace).Get(ws.app.ctx, name, metav1.GetOptions{})
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	// Get detailed info
	spec, _, _ := unstructured.NestedMap(app.Object, "spec")
	status, _, _ := unstructured.NestedMap(app.Object, "status")

	// Extract sync history
	var syncHistory []map[string]interface{}
	if history, found, _ := unstructured.NestedSlice(status, "history"); found {
		for _, h := range history {
			if hMap, ok := h.(map[string]interface{}); ok {
				syncHistory = append(syncHistory, map[string]interface{}{
					"id":         hMap["id"],
					"revision":   hMap["revision"],
					"deployedAt": hMap["deployedAt"],
					"source":     hMap["source"],
				})
			}
		}
	}

	// Extract resource status
	var resources []map[string]interface{}
	if res, found, _ := unstructured.NestedSlice(status, "resources"); found {
		for _, r := range res {
			if rMap, ok := r.(map[string]interface{}); ok {
				resources = append(resources, map[string]interface{}{
					"kind":      rMap["kind"],
					"name":      rMap["name"],
					"namespace": rMap["namespace"],
					"status":    rMap["status"],
					"health":    rMap["health"],
				})
			}
		}
	}

	// Get conditions
	var conditions []map[string]interface{}
	if conds, found, _ := unstructured.NestedSlice(status, "conditions"); found {
		for _, c := range conds {
			if cMap, ok := c.(map[string]interface{}); ok {
				conditions = append(conditions, map[string]interface{}{
					"type":    cMap["type"],
					"status":  cMap["status"],
					"message": cMap["message"],
				})
			}
		}
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":      true,
		"name":         app.GetName(),
		"namespace":    app.GetNamespace(),
		"spec":         spec,
		"status":       status,
		"history":      syncHistory,
		"resources":    resources,
		"conditions":   conditions,
		"historyCount": len(syncHistory),
	})
}

// handleArgoCDSync triggers a sync for an ArgoCD Application
func (ws *WebServer) handleArgoCDSync(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if r.Method != "POST" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Method not allowed",
		})
		return
	}

	if ws.app.config == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	// Parse request body
	var req struct {
		Name      string `json:"name"`
		Namespace string `json:"namespace"`
		Prune     bool   `json:"prune"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Invalid request body: " + err.Error(),
		})
		return
	}

	if req.Name == "" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name is required",
		})
		return
	}

	// Default to argocd namespace if not specified
	if req.Namespace == "" {
		req.Namespace = "argocd"
	}

	dynamicClient, err := dynamic.NewForConfig(ws.app.config)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	appGVR := schema.GroupVersionResource{
		Group:    "argoproj.io",
		Version:  "v1alpha1",
		Resource: "applications",
	}

	// Get current app
	app, err := dynamicClient.Resource(appGVR).Namespace(req.Namespace).Get(ws.app.ctx, req.Name, metav1.GetOptions{})
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Failed to get application: " + err.Error(),
		})
		return
	}

	// Set operation to trigger sync
	operation := map[string]interface{}{
		"sync": map[string]interface{}{
			"prune": req.Prune,
		},
	}
	unstructured.SetNestedMap(app.Object, operation, "operation")

	// Update the application to trigger sync
	_, err = dynamicClient.Resource(appGVR).Namespace(req.Namespace).Update(ws.app.ctx, app, metav1.UpdateOptions{})
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Failed to trigger sync: " + err.Error(),
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": fmt.Sprintf("Sync triggered for %s", req.Name),
		"name":    req.Name,
	})
}

// handleArgoCDRefresh triggers a refresh for an ArgoCD Application
func (ws *WebServer) handleArgoCDRefresh(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if r.Method != "POST" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Method not allowed",
		})
		return
	}

	if ws.app.config == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Not connected to cluster",
		})
		return
	}

	// Parse request body
	var req struct {
		Name      string `json:"name"`
		Namespace string `json:"namespace"`
		Hard      bool   `json:"hard"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Invalid request body: " + err.Error(),
		})
		return
	}

	if req.Name == "" {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "name is required",
		})
		return
	}

	// Default to argocd namespace if not specified
	if req.Namespace == "" {
		req.Namespace = "argocd"
	}

	dynamicClient, err := dynamic.NewForConfig(ws.app.config)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	appGVR := schema.GroupVersionResource{
		Group:    "argoproj.io",
		Version:  "v1alpha1",
		Resource: "applications",
	}

	// Get current app
	app, err := dynamicClient.Resource(appGVR).Namespace(req.Namespace).Get(ws.app.ctx, req.Name, metav1.GetOptions{})
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Failed to get application: " + err.Error(),
		})
		return
	}

	// Update refresh annotation to trigger refresh
	annotations := app.GetAnnotations()
	if annotations == nil {
		annotations = make(map[string]string)
	}

	if req.Hard {
		annotations["argocd.argoproj.io/refresh"] = "hard"
	} else {
		annotations["argocd.argoproj.io/refresh"] = "normal"
	}
	app.SetAnnotations(annotations)

	// Update the application to trigger refresh
	_, err = dynamicClient.Resource(appGVR).Namespace(req.Namespace).Update(ws.app.ctx, app, metav1.UpdateOptions{})
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   "Failed to trigger refresh: " + err.Error(),
		})
		return
	}

	refreshType := "normal"
	if req.Hard {
		refreshType = "hard"
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":     true,
		"message":     fmt.Sprintf("Refresh (%s) triggered for %s", refreshType, req.Name),
		"name":        req.Name,
		"refreshType": refreshType,
	})
}

// FluxResource represents a Flux resource (Kustomization, HelmRelease, GitRepository, etc.)
type FluxResource struct {
	Kind      string `json:"kind"`
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
	Ready     string `json:"ready"`
	Status    string `json:"status"`
	Age       string `json:"age"`
	SourceRef string `json:"sourceRef,omitempty"`
	Revision  string `json:"revision,omitempty"`
}

// handleFluxResources returns Flux resources
func (ws *WebServer) handleFluxResources(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if ws.app.config == nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     "Not connected to cluster",
			"installed": false,
		})
		return
	}

	namespace := r.URL.Query().Get("namespace")

	// Create dynamic client for CRD access
	dynamicClient, err := dynamic.NewForConfig(ws.app.config)
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     err.Error(),
			"installed": false,
		})
		return
	}

	var resources []FluxResource
	fluxInstalled := false

	// Flux CRD definitions
	fluxCRDs := []struct {
		group    string
		version  string
		resource string
		kind     string
	}{
		{"kustomize.toolkit.fluxcd.io", "v1", "kustomizations", "Kustomization"},
		{"helm.toolkit.fluxcd.io", "v2", "helmreleases", "HelmRelease"},
		{"source.toolkit.fluxcd.io", "v1", "gitrepositories", "GitRepository"},
		{"source.toolkit.fluxcd.io", "v1", "helmrepositories", "HelmRepository"},
		{"source.toolkit.fluxcd.io", "v1", "ocirepositories", "OCIRepository"},
	}

	for _, crd := range fluxCRDs {
		gvr := schema.GroupVersionResource{
			Group:    crd.group,
			Version:  crd.version,
			Resource: crd.resource,
		}

		var list *unstructured.UnstructuredList
		if namespace == "" || namespace == "All Namespaces" {
			list, err = dynamicClient.Resource(gvr).Namespace("").List(ws.app.ctx, metav1.ListOptions{})
		} else {
			list, err = dynamicClient.Resource(gvr).Namespace(namespace).List(ws.app.ctx, metav1.ListOptions{})
		}

		if err != nil {
			// CRD not found, skip
			continue
		}

		fluxInstalled = true

		for _, item := range list.Items {
			ready := "Unknown"
			statusMsg := ""
			revision := ""
			sourceRef := ""

			// Get status conditions
			if status, ok := item.Object["status"].(map[string]interface{}); ok {
				if conditions, ok := status["conditions"].([]interface{}); ok {
					for _, cond := range conditions {
						if condMap, ok := cond.(map[string]interface{}); ok {
							if condType, _ := condMap["type"].(string); condType == "Ready" {
								if condStatus, _ := condMap["status"].(string); condStatus == "True" {
									ready = "True"
								} else {
									ready = "False"
								}
								if msg, _ := condMap["message"].(string); msg != "" {
									statusMsg = msg
									// Truncate long messages
									if len(statusMsg) > 50 {
										statusMsg = statusMsg[:47] + "..."
									}
								}
								break
							}
						}
					}
				}

				// Get last applied revision
				if rev, ok := status["lastAppliedRevision"].(string); ok {
					revision = rev
				} else if rev, ok := status["artifact"].(map[string]interface{}); ok {
					if r, ok := rev["revision"].(string); ok {
						revision = r
					}
				}
			}

			// Get source reference for Kustomizations and HelmReleases
			if spec, ok := item.Object["spec"].(map[string]interface{}); ok {
				if sr, ok := spec["sourceRef"].(map[string]interface{}); ok {
					kind, _ := sr["kind"].(string)
					name, _ := sr["name"].(string)
					sourceRef = fmt.Sprintf("%s/%s", kind, name)
				}
			}

			creationTime := item.GetCreationTimestamp()

			resources = append(resources, FluxResource{
				Kind:      crd.kind,
				Name:      item.GetName(),
				Namespace: item.GetNamespace(),
				Ready:     ready,
				Status:    statusMsg,
				Age:       formatAge(time.Since(creationTime.Time)),
				SourceRef: sourceRef,
				Revision:  revision,
			})
		}
	}

	if !fluxInstalled {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   true,
			"resources": []FluxResource{},
			"count":     0,
			"installed": false,
			"message":   "Flux is not installed in this cluster",
		})
		return
	}

	// Sort by kind then namespace then name
	sort.Slice(resources, func(i, j int) bool {
		if resources[i].Kind != resources[j].Kind {
			return resources[i].Kind < resources[j].Kind
		}
		if resources[i].Namespace != resources[j].Namespace {
			return resources[i].Namespace < resources[j].Namespace
		}
		return resources[i].Name < resources[j].Name
	})

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":   true,
		"resources": resources,
		"count":     len(resources),
		"installed": true,
	})
}
